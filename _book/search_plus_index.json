{"./":{"url":"./","title":"关于","keywords":"","body":"前端知识点总结 (闲来无事，随手记录) 前端知识整理，分为css、js、vue、react、node、leetCode算法等部分 持续更新ing... 线上访问地址 项目地址,欢迎一起完善 "},"docs/CSS.html":{"url":"docs/CSS.html","title":"css部分","keywords":"","body":"实现垂直居中的方法 1. display: table-cell方法 Content goes here #wrapper { display: table; } #cell { display: table-cell; vertical-align: middle; } .content{ display: inline-block; } Internet Explorer(甚至 IE8 beta)中无效 2. 高度已知时，position: absolute; top: 50%; margin-top: -contentheight;实现 Content goes here #content { position: absolute; top: 50%; height: 240px; margin-top: -120px; /* negative half of the height */ } div 在 body 内，当用户缩小浏览器窗口，滚动条不出现 3. 高度已知时，元素外插入一个父级 div。设置此 div height:50%; margin-bottom:-contentheight; 元素清除浮动，显示在中间 Content here #floater { float: left; height: 50%; margin-bottom: -120px; } #content { clear: both; height: 240px; position: relative; } 4. 宽高已知时，这个方法使用了一个 position:absolute，这个 div 被设置为 top:0; bottom:0;。但是因为它有固定高度，其实并不能和上下都间距为 0，因此 margin:auto; 会使它居中。使用 margin:auto;使块级元素垂直居中是很简单的 Content here #content { position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; height: 240px; width: 70%; } 缺点第一个和第二个合集 5. css3 top: 50%;transform: translateY(-50%);(IE8及以前不支持) 6. 文本的垂直居中 line-height 实现水平垂直居中的方法 (方法1和2脱离了文档流) 1. 宽高一定时，margin: auto法，同上文第四种方法 2. 宽高一定时，负margin法，position: absolute; margin-top: -contentheight;margin-left: -contentheight; 3. 文字图片类使用 display: table-cell法 div{ width: 260px; height: 230px; display: table-cell; vertical-align: middle; text-align: center; } img{ vertical-align: middle; } 4. css3 top: 50%; left: 50%; transform: translate3d(-50%, -50%);(IE8及以前不支持) 5. 弹性布局，dispaly: flex .container{ width: 300px; height: 200px; border: 3px solid #546461; display: -webkit-flex; display: flex; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center; } .inner{ border: 3px solid #458761; padding: 20px; } 6. 利用calc函数进行四则运算(IE9及以上) .calc{ position: relative; } .calc .innerBox{ position: absolute; left:-webkit-calc((500px - 200px)/2); top:-webkit-calc((120px - 50px)/2); left:-moz-calc((500px - 200px)/2); top:-moz-calc((120px - 50px)/2); left:calc((500px - 200px)/2); top:calc((120px - 50px)/2); } 实现瀑布流布局 /*瀑布流层*/ .waterfall{ -moz-column-count:4; /* Firefox */ -webkit-column-count:4; /* Safari 和 Chrome */ column-count:4; /*规定多少列*/ -moz-column-gap: 1em; /*每一列的间隙*/ -webkit-column-gap: 1em; column-gap: 1em; // column-width: 1em; /*每一列的宽度*/ } /*内容层*/ .item{ -moz-page-break-inside: avoid; -webkit-column-break-inside: avoid; break-inside: avoid; /*避免元素内部断行并产生新列*/ } 注意: Internet Explorer 9及更早 IE 版本浏览器不支持 column-count 属性。 三栏布局 1. 左右浮动，中间不动. .left { float: left; height: 200px; width: 100px; background-color: red; } .right { width: 200px; height: 200px; background-color: blue; float: right; } .main { margin-left: 120px; margin-right: 220px; height: 200px; background-color: green; } 2. 双飞翼布局 .content { float: left; width: 100%; } .main { height: 200px; margin-left: 110px; margin-right: 220px; background-color: green; } .left { float: left; height: 200px; width: 100px; margin-left: -100%; background-color: red; } .right { width: 200px; height: 200px; float: right; margin-left: -200px; background-color: blue; } 3. 圣杯布局 .container { margin-left: 120px; margin-right: 220px; } .main { float: left; width: 100%; height: 300px; background-color: red; } .left { float: left; width: 100px; height: 300px; margin-left: -100%; position: relative; left: -120px; background-color: blue; } .right { float: left; width: 200px; height: 300px; margin-left: -200px; position: relative; right: -220px; background-color: green; } 4. flex布局 ie10+ .container { display: flex; } .main { flex-grow: 1; height: 300px; background-color: red; } .left { order: -1; flex: 0 1 200px; margin-right: 20px; height: 300px; background-color: blue; } .right { flex: 0 1 100px; margin-left: 20px; height: 300px; background-color: green; } 关于flex布局 5. table布局(无法设置栏间距) .container { display: table; width: 100%; } .left, .main, .right { display: table-cell; } .left { width: 200px; height: 300px; background-color: red; } .main { background-color: blue; } .right { width: 100px; height: 300px; background-color: green; } 6. 绝对定位布局 .container { position: relative; } .main { height: 400px; margin: 0 120px; background-color: green; } .left { position: absolute; width: 100px; height: 300px; left: 0; top: 0; background-color: red; } .right { position: absolute; width: 100px; height: 300px; background-color: blue; right: 0; top: 0; } "},"docs/JS.html":{"url":"docs/JS.html","title":"js部分","keywords":"","body":"JavaScript一些知识点 ES6 Call和Apply js的数据类型 原始类型： Boolean Null Number String Undefined Symbol(es6) 非原始类型： Object 6中ajax方法：get、post、delete、put、options、head function ajaxRequest(type, url, data){ var xmlhttp; if(window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp = new window.XMLHttpRequest(); }else{// code for IE6, IE5 xmlhttp = new ActiveXObject(\"Microsoft.XMlHTTP\"); } if(type.toLocalCase() == \"get\"){// get方法 // 定义请求方式、请求地址以及是否异步，添加一个id避免使用缓存 xmlhttp.open(\"GET\", \"test.php?_=\" + new Date().getTime(), true); xmlhttp.send(); }else{// post方法，需要设置HTTP头，然后在send()方法中发送数据(send内的参数为string) xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencode\"); xmlhttp.open(\"POST\", \"test.php\", true); xmlhttp.send(\"fname=Bill&lname=Gates\"); } // xmlhttp.onreadystatechange=function(){ // if (xmlhttp.readyState==4 && xmlhttp.status==200){ // document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; // } // } /* 关于(readyState): 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 关于(status): 200: \"OK\" 404: 未找到页面 */ xmlhttp.onreadystatechange=function(){ if(xmlhttp.readyState == 4){ if(xmlhttp.status == 200){ console.log(xmlhttp.responseText); } } } } bind的实现 Function.prototype.bind = function(context){ var args = Array.prototype.slice(arguments, 1), F = function(){}, self = this, bound = function(){ var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return self.apply((this instanceof F ? this : context), finalArgs); }; F.prototype = self.prototype; bound.prototype = new F(); retrun bound; }; "},"docs/LEETCODE.html":{"url":"docs/LEETCODE.html","title":"leetCode算法题","keywords":"","body":"leetCode算法题目加答案 你也可以去试试leetCode(中国)的算法题 在算法题之前，先来几个经典的算法 菲波那切数列 //1，1，2，3，5，8，13，21这个数列 斐波那契 数列 //得到第9项是几？ /* 递归方法 */ function Fibonacci(index){ if (index 数组的交、差、并 var a = [1, 2, 3, NaN]; var b = [2, 4, 5]; // ES7 // 数组的并集 let union = a.concat(b.filter(v => !a.includes(v))); console.log(union); // [1,2,3,4,5] // 数组的交集 let intersection = a.filter(v => b.includes(v)); console.log(intersection); // [2] // 数组的差集 let difference = a.concat(b).filter(v => !a.includes(v) || !b.includes(v)); console.log(difference); // [1, 3, 4, ,5] // ES6 let aSet = new Set(a); let bSet = new Set(b); // 并集 let union = Array.from(new Set(a.concat(b))); console.log(union); // 交集 let inheritAttrs = Array.from(new Set(a.filter(v => bSet.has(v)))) console.log(inheritAttrs); // 差集 let difference = Array.from(new Set(a.concat(b).filter(v => !aSet.has(v) || !bSet.has(v)))) console.log(difference); //ES5 // 判断是否有NaN出现 var aHasNaN = a.some(function (v) { return isNaN(v) }) var bHasNaN = b.some(function (v) { return isNaN(v) }) //并集 var union = a.concat(b.filter(function (v) { return a.indexOf(v) === -1 && !isNaN(v) })).concat(!aHasNaN & bHasNaN ? [NaN] : []); console.log(union); //交集 var intersection = a.filter(function (v) { return b.indexOf(v) > -1 }).concat(!aHasNaN & bHasNaN ? [NaN] : []); console.log(intersection); //差集 var difference = a.concat(b).filter(function (v) { return (a.indexOf(v) === -1 || b.indexOf(v) === -1) && !isNaN(v) }).concat(!aHasNaN & bHasNaN ? [NaN] : []) for (let i = 0; i 算法题及答案 数组部分 数组去重 var removeDuplicates = function(nums) { var a = {}, b = []; for(var i = 0; i [1,2,4] /* 在浏览器上是可以实现的，但在leetCode 运行平台上实现不了，不知什么原因*/ 2. "},"docs/GIT.html":{"url":"docs/GIT.html","title":"git相关","keywords":"","body":"git相关知识 git 撤销上一次的commit操作 请看 git取消文件add暂存 git reset HEAD "}}